Chapter 8: Graphs

8.1 Objectives

1. To learn what a graph is and how it is used.
2. To implement the graph abstract data type using multiple representations
3. To see how graphs can be used to solve multiple different problems. 

Some examples of graphs could be a road map, a highway connection, or any network.

    8.2 Vocabulary

Vertex: A vertex (also called a “node”) is a fundamental part of a graph. It can have a name, which we will call the “key.” A vertex may also have additional information. We will call this additional information the “payload.”
Edge: An edge (also called an “arc”) is another fundamental part of a graph. An edge connects two vertices to show that there is a relationship between them. Edges may be one-way or two-way. If the edges in a graph are all one-way, we say that the graph is a directed graph, or a digraph. The class prerequisites graph shown above is clearly a digraph since you must take some classes before others.
Weight: Edges may be weighted to show that there is a cost to go from one vertex to another. For example in a graph of roads that connect one city to another, the weight on the edge might represent the distance between the two cities.
Path: A path in a graph is a sequence of vertices that are connected by edges. Formally we would define a path as w1,w2,...,wn
such that (wi,wi+1)∈E for all 1≤i≤n−1. The unweighted path length is the number of edges in the path, specifically n−1. The weighted path length is the sum of the weights of all the edges in the path. For example in Figure 2 the path from V3 to V1 is the sequence of vertices (V3,V4,V0,V1). The edges are {(v3,v4,7),(v4,v0,1),(v0,v1,5)}
Cycle: A cycle in a directed graph is a path that starts and ends at the same vertex. For example, in Figure 2 the path (V5,V2,V3,V5)
is a cycle. A graph with no cycles is called an acyclic graph. A directed graph with no cycles is called a directed acyclic graph or a DAG. We will see that we can solve several important problems if the problem can be represented as a DAG.

    8.3 The Graph ADT

Graph() creates a new, empty graph.
addVertex(vert) adds an instance of Vertex to the graph.
addEdge(fromVert, toVert) Adds a new, directed edge to the graph that connects two vertices.
addEdge(fromVert, toVert, weight) Adds a new, weighted, directed edge to the graph that connects two vertices.
getVertex(vertKey) finds the vertex in the graph named vertKey.
getVertices() returns the list of all vertices in the graph.
in returns True for a statement of the form vertex in graph, if the given vertex is in the graph, False otherwise.

    8.4 An adjacency matrix

One of the easiest ways to make a graph is to just represent it with a 2D array. Items are entered 

    8.5 An adjacency list

Another way to imlpement a graph is to use an adjacency list. The advantage of this is that the adjacency list is a good way to represent a sparse graph. 

    8.6 implementation

    8.9 Breadth First Search

A Breadth first search is one of the easiest algorithms to do with a graph. How it works is you literally "brute force" your way through a graph. 

It's similar to a sequential search in that it's fairly easy to implement and it doesn't have amazing performance.

It works by assigning states, represented by colors to the nodes of the graph. a white node is completely unvisited. A gray node has been visited, but might have white neighbors. And a black node is visited as well as all of its neighbors. As we visit nodes, we sequentially add their neightbors to a heap and then pop the node that we visited, so on and so forth until we either reach what we were searching for or we go to the end of the graph.

    A good way of visualizing it is we are searching "horizontally", as we are visiting the nodes one level at a time.

    8.10 Depth First Search

Instead of searching for nodes one level at a time, a depth first search will go as deeply into a tree as possible, and then backtrack on the next level and repeat.

    8.15 General Depth First Search

The goal of a general depth first search is to connect as many nodes as possible and branching where necessary.

We can even create more than one tree with a depth first search. This is called a depth first forest. We use two new variables with this tree, that being discovery and finish times. The discovery time tracks the number of steps in the algorithm before a vertex is first encountered. The finish time is the number of steps in the algorithm before a vertex is colored black. These times can be used as important data for other algorithms.

    8.16 General Depth First Search performance

O(V+E)

    8.17 Topological Sorting

What if we wanna walk through a graph in order? Some graphs must have this requirement.
Simply label the node and the order, starting at the number of commands and decreasing by 1 for every step until 0. You don't really even need edges, just walk from node to node and draw the edges as you like.

    8.18 Strongly connected graphs

When we have a graph with a lot of edges, we can use an algorithm to group together the larger clusters that are heavily related to each other. This is called the strongly connected component algorithm.

    8.19 Shortest path problems

Sometimes we need to find the shortest path through a graph.



