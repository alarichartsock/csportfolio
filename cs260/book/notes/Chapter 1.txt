1.2: Getting Started

This chapter emphasizes two important ideas for the rest of the text:
	It reviews the framework within which computer science and the study of algorithms and data structures must fit
	It will review Python.

1.3: What is Computer Science?

Computer science is the studynig of problems, problem-solving, and the solutions that come out of the problem solving process.

Some problems, however, are not solvable. That is beyond the scope of this text or this chapter.

Sometimes, we refer to the word computable when describing problems and solutions. We say that if a problem is computable, then there exists an algorithm, or a solution, for it.

Computer Science is also the study of abstraction. Abstraction allows us to separate the so-called logical and physical perspectives of a problem & solution.

Procedural abstraction is when we know what to do, but not exactly how it gets done. For example, when we import a math library and we use the square root function. All we know when we use that function is that it is squaring the input we give it. Not what is happening under the hood.

1.4: What is Programming?

Programming is the process of taking an algorithm and encoding it into a notation, a programming language to be executed by a computer.

Computer science is not the study of programming. Programming, however is an important part of what a computer scientist does.

All data items in the computer are represented as strings of binary digits. In order to give these strings meaning, we need to have data types. Data types provide an interpretation for this binary data so that we can think about the data in terms that make sense with respect to the problem being solved.

1.5: Why Study Data Structures and Abstract Data Types?

Because it allows us to use them more efficiently.

Earlier we referred to procedural abstraction as a process that hides the details of a particular function to allow the user or client to view it at a very high level. We now turn to a similar idea, that of data abstraction. An astract data type, sometimes abbreviated ADT, is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented.

1.6: Why Study Algorithms?

Computer scientists learn by experience. By exposing ourselves to new ideas and ways of problem solving, we are challenging ourselves and allowing ourselves to grow.

1.7: Review of Basic Python

Literally just a print function lol

1.8: Getting Started with Data

In Python, we define a class to be a description of what the data looks like (the state) and what the data can do (the behavior).

1.8.1: Built in Atomic Data Types

Python has two numeric data types: float and int.

We have standard arithmetic operators: +, -, *, /, and ** (exponentiation).
We also have the modulo operaotr, and integer division, //. When two integers are divided, it produces a float.

The boolean daa type, represented as the Python bool class, will be quite useful for representing truth values. The only values that bool can store are true and false.

Boolean data objects are also used as results for comparison operators, such as equality (==) and greater than(>).

less than : < 
greater than : >
less than or equal: <=
greater than or euqal: >=
equal: ==
not equal: !=
logical and: and
logical or: or
logical not: not

Identifiers are used in programming languages as names. In Python, identifiers start with a letter or an underscore, are case sensitive, and can be of any length.

!!>>In python, when we use an assignment operator, we are creating a reference. We are not filling that object with a value. We are simply having it point at another class.This is VERY IMPORTANT to understand.<<!!

1.8.2 Built in Collection Data Types

Python also has powerful built in collection data types, such as Lists, Strings, and tuples which are ordered collections that are very similar in general structure but have specific differences.

A list is an ordered collection of zero or more references to Python data objects. Lists are written as commma-delimited values enclosed in square brackets. An empty list is jsut [ ]. Lists are heterogeneous, meaning that the data objects don't need to be all the same class and the colection can be assigned as a variable as below:

>>>myList = [1,3,True,6.5]
>>>myList
[1,3,True,6.5]

Here are some operations that can be run on Lists:

indexing: [] : Access an element of a sequence
concatenation: + : Combine sequences together
repetition: * : Concatenate a repeated number of times
membership: in: Ask whether an item is in a sequence
length: len : Ask the number of items in a sequence
slicing: [ : ] : Extract a part of a sequence

The indices of a list start counting at 0.

You can initialize a list pretty fast like so:

>>>myList = [0] * 6
>>>myList
[0,0,0,0,0,0]

Here are some methods we can use with Lists:

append: adds a new item to the end of a list
insert: inserts an item at the ith position in a list
pop: removes and returns the last item in a list
pop(i): removes and returns the ith item in a list
sort:  modifies the list to be sorted
reverse: modifies a list to be in reverse order
del: deletes the item in ith position
index: returns the index of the first occurences of item
remove: removes the first ocurrence of item

Methods provided by Strings in Python

center : astring.center(w) : Returns a string centered in a field of size w
count : astring.count(item) : Returns the number of occurrences of item in the string 
Ijust : astring.ljust(w) : Returns a string left-justified in a field of size 
lower : astring.lower() : Returns a string in all lowercase
rjust  : astring.rjust(w) : Returns a string right-justified in a field of size w
find : astring.find(item) : Returns the index of the first occurrence of item
split : astring.split(schar) : Splits a string into substrings at schar

Tuples are very similar to lists, they are heterogeneous sequences of data.

Strings are immutable.

Sets are heterogeneous, and the collection can be assigned to a variable.

Set operations

membership : in : Set membership
length : len : Returns the cardinality of the set
| : aset | otherset : Returns a new set with all elements from both sets
& : aset & otherset : Returns a new set with only those elements common to both sets
- : aset - otherset : Returns a new set with all items from the first set not in second
<= : aset <= otherset : Asks whether all elements of the first set are in the second

Methods provided by Sets in Pyrthon

union : aset.union(otherset) : Returns a new set with all elements from both sets
intersection : aset.intersection(otherset) : Returns a new set with only those elements common to both sets
difference : aset.difference(otherset) : Returns a new set with all items from first set not in second
issubset : aset.issubset(otherset) : Asks whether all elements of one set are in the other
add : aset.add(item) : Adds item to the set
remove : aset.remove(item) : Removes item from the set
pop : aset.pop() : Removes an arbitrary element from the set
clear : aset.clear() : Removes all elements from the set

The final Python collection is called a Dictionary. A dictionary works with pairs, called key value pairs. A key is assigned to a value, and those are ordered.

ex:

capitals  = {"Iowa":"DesMoines","Wisconsin":"Madison"}

Methods provided by dictionary.

keys : adict.keys() : Returns the keys of the dictionary in a dict_keys object
values : adict.values()  : Returns the values of the dictionary in a dict_values object
items : adict.items() : Returns the key-value pairs in a dict_items object
get : adict.get(k) : Returns the value associated with k, None otherwise
get : adict.get(k,alt) : Returns the value associated with k, alt otherwise

1.9: Input and Output

Collect input in python by: aName = input("Enter input")

Formatted strings are pretty interesting. To do them, type % followed by a signifier.

example: print("%s is %d years old." % (aName,age))

d, i: Integer
u: Unsigned integer
f: Floating point as m.ddddd
e: Floating point as m.dddde+/-xx
E: Floating point as m.ddddE+/-xx
g: Use %e for exponents less than -4 or greater than +5, otherwise use %f
c: Single character
s: String, or any Python data object that can be converted to a string by using the str function
%: Insert a literal % character.

In addition to format character, you can also use addditional formatting options.

number : %20d
- : %-20d : Put the value in a field 20 characters wide, left justified
+ : %+20d : Put the value in a field 20 characters wide, right justified
0: %020d : Put the value in a field 20 characters wide, fill in with leading zeros.
. : %20.2f : Put the value in a field 20 characters wide with 2 charactrs to the right of the decimal point.
(name) : %(name)d : Get the value from the supplied dictionary using name as the key.

1.10: Control Structures

For iteration, Python provides a standard while statement and a powerful for statement.

while (evaluative statement):
	do()

That's about it for the while loop.

The for statement can loop over lists like so:

for item in [1,2,3,4,5,6]:
	print("hey")

for item in range(5):
	print(item**2)

For selection statements, we have the if statement.

if(conditional):
	print("hel")
else:
	print("heee")

But there are more ways to add to the if statement. We can use elif as well.

1.11 Exception Handling

We can come across two types of errors in programming. Syntax errors, and logic errors. A syntax error is when we forget a semicolon or a tab, and a logic error is when a program executes but gives the wrong error.

When a logical error is "raised", we can "handle" the exception. We can do this by using a try statement.

try:
	#action
except:
	#if failed, do this

We can also cause a runtime exception, by using the raise statement.

There are lots of exceptions that can be raised in addition ro RuntimeError.

1.12 Defining Functions

We define functions (methods) with the def keyword. Example:

def square(n):
	return n**2

That;s about it. Python doesn't have return types or parameter typing (as far as I know).

1.13 Object Oriented Programming in Python: Defining Classes

We can create a class in Python using the class keyword. Then we can define our constructor, which in Python is __init__(params):

We can also override methods in Python. For example:

def __str__(self):
	return str(self.num)+"/"+str(self.den)

1.14 Summary

1.15 Key Terms
