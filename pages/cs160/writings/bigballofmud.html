<DOCTYPE html>
    <html>
    <head>
        <title>CS160</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="./writings.css">
    </head>

    <body>
        <nav>
            <p>Alaric Hartsock</p>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li><a href="#">Classwork</a>
                    <ul>
                        <li>
                            <a href="../cs160.html">CS160</a>
                        </li>
                        <li>
                            <a href="../../cs161/cs161.html">CS161</a>
                        </li>
                        <li>
                            <a href="../../cs162/cs162.html">CS162</a>
                        </li>
                        <li>
                            <a href="../../cs260/cs260.html">CS260</a>
                        </li>
                    </ul>
                </li>
                <li><a href="#">Side Projects</a></li>
                <li><a href="#">About me</a></li>
            </ul>
        </nav>
        <div class="Center-Container">
          <a href="https://pressupinc.com/blog/2015/04/why-software-becomes-a-big-ball-of-mud/"> <h2>"Why Software Becomes a Big Ball of Mud" Summary</h2></a>
          <p>
            The article goes over approximately 8 reasons why the big ball of mud anti pattern is so prevalent within the realm of software. First is financial and time pressures, teams are expected to deliver the most for the cheapest and fastest. Second is unskilled or inexperienced developers, which is self explanatory and very related to the aforementioned financial and time pressures. The third reason is the "invisibility" of software architecture. While a prospective home buyer might be able to waltz in to a building in development and observe a hole in the floor, the commisioner of a software project would have a much harder time observing deep seeded vulnerabilities in software. Simply put: it is much easier to conceal software vulnerabilities than other tangible objects. Fourth, the author then goes on to mention piecemental growth and mentions how much legacy code is relied upon within software development. Fifth the author mentions unexpected change to a projects scale. It's quite common to witness a project that was merely hobbled together grow quite fast due to viral discovery on the internet. Due to unexpected traffic it's expected that these projects will fail. Finally, the author mentions inherent complexity. Some software solutions are just inherently complex due to the problem that they are going to solve, and if we're honest then we'll admit that the software implementation heavily increases this complexity.<br></br>

            I agree for the most part with this thinking, not that the big ball of mud is the best way to go when designing software, but that there is anything that is true about software development it's that expectations take a back seat to market pressures. The big ball of mud is common because of the all too common scenario of projects expected to do the impossible with the smallest budget. I think of it like a triangle: you get to choose two out of three options: Cheap, Short Production Time, and Reliable. If it’s cheap and has a short production time then it’s not reliable. If it’s got a short production time and it’s reliable then it’s not cheap. If it’s Reliable and Cheap then it’s got a long production time. Each individual team has to select what they value. However it goes without saying that having money and time is no clear indication that a project will do well as plenty of projects with large budgets fail spectacularily. Either way, the big ball of mud can be looked at as a natural conclusion to lots of typical team dynamics like developer turnover, code entropy, and business pressures.
          </p>
        </div>
    </body>

    </html>
