<DOCTYPE html>
    <html>
    <head>
        <title>CS160</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="./writings.css">
    </head>

    <body>
        <nav>
            <p>Alaric Hartsock</p>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li><a href="#">Classwork</a>
                    <ul>
                        <li>
                            <a href="../cs160.html">CS160</a>
                        </li>
                        <li>
                            <a href="../../cs161/cs161.html">CS161</a>
                        </li>
                        <li>
                            <a href="../../cs162/cs162.html">CS162</a>
                        </li>
                        <li>
                            <a href="../../cs260/cs260.html">CS260</a>
                        </li>
                    </ul>
                </li>
                <li><a href="#">Side Projects</a></li>
                <li><a href="#">About me</a></li>
            </ul>
        </nav>
        <div class="Center-Container">
            <a href=http://gamearchitect.net/Articles/SoftwareIsHard.html><h2>"Software is Hard" Summary</h2></a>
            <br>
            <p>Software is hard because the very main thing that makes it so beautiful makes it incredibly difficult as well. That is to say that the amazing ability to create anything anything and everything also comes with the downside of the ability to create anything and everything. That includes bugged software, useless features, security flaws, and the unholy grail of software: dead, useless, expensive software. Apart from the fact that you can build anything, many teams fail to define an endpoint, and keep elaborating past their original goals or worse: elaborate to different goals before the original goals are met. The article mentions that you can’t quantify when a software program is done and this is very true. We hang onto lines of code as if it is the end all be all signifying factor in a softwares lifecycle, that we know when we reach an arbitrary number of lines of code that surely we have made it. But this isn’t useful and it would be silly to quantify software based on this despite that many people do. We can’t visualize it very easily because projects become so big it would be almost impossible to comprehend the amount of code we have written in any other format than just the number of lines written.</p>
    </body>

    </html>
